1. Μια σύντομη και περιεκτική εξήγηση για τις επιλογές που έχετε κάνει στο σχεδιασμό του προγράμματος
σας (2-3 σελίδες σε ASCII κείμενο είναι αρκετές).

exec*(), mkfifo(), pipe(), open(), close(), read(), write(),
wait(), waitpid(), poll(), select(), dup(), dup2(), kill() και exit().

Σε αυτές τις «χρήσιμες»
λέξεις ΔΕΝ περιλαμβάνονται οι λέξεις του exclusion list που παρέχονται σε ένα αρχείο με την μορφή in-line
parameter σε κάθε εκτέλεση του lexan.

Το τελικό αποτέλεσμα της ιεραρχίας είναι οι k πιο ‘δημοφιλείς’ λέξεις
(δηλ. top-k) που εμφανίζονται στο κείμενο.

οι εσωτερικοί κόμβοι (splitters) αναθέτουν εργασία σε υποκείμενους (builders).Οι τελευταίοι
οργανώνουν τις συλλεγμένες πληροφορίες ώστε να μπορούν να υπολογιστούν οι συχνότητες λέξεων, τις οποίες
και παραδίδουν στον κόμβο συντονισμού που δημιουργεί μεταξύ άλλων, την παρουσίαση αποτελεσμάτων σε ένα
γράφημα.

Οι επικοινωνίες μεταξύ κόμβων (δηλ.
διεργασιών) σε διάφορα επίπεδα γίνεται με την χρήση είτε pipes είτε named-pipes (FIFOs).

Ο στόχος
της ιεραρχίας είναι να βρίσκει την συχνότητα λέξεων που παρουσιάζουν ‘ενδιαφέρον’ σε ένα κείμενο και έτσι
μπορεί να το ορίζουν πιθανώς μονοσήμαντα ή και να το οριοθετούν/tag.

Ο root κόμβος παρέχει στους splitters
το εύρος γραμμών μέσα σε ένα αρχείο που οι τελευταίοι θα πρέπει να διαβάσουν και να δημιουργήσουν απλές
ακολουθίες από λέξεις (χωρίς σύμβολα, παρενθέσεις, σημεία στίξης, κλπ.). Οι builders απλά δημιουργούν
λίστες λέξεων που έχουν βρεθεί με αντίστοιχους μετρητές συχνότητας. ΄Οταν ολοκληρώσουν την εργασία τους,
οι builders στέλνουν τα επιμέρους αποτελέσματα τους στον root ο οποίος τα συνθέτει και παράγει τις top-k πιο
συχνές λέξεις, τυπώνει στατιστικά εκτέλεσης των διεργασιών στην ιεραρχία και τερματίζει.

1. Οι τρεις τύποι κόμβων που αποτελούν την ιεραρχία αντιπροσωπεύουν ανεξάρτητα αλλά συνεργαζόμενα
προγράμματα.

2. Οι τρεις τύποι κόμβων που αποτελούν την ιεραρχία αντιπροσωπεύουν ανεξάρτητα αλλά συνεργαζόμενα
προγράμματα.

3. Σύμφωνα με τον αριθμό l που έχει καθοριστεί στην γραμμή κλήσης του κυρίου προγράμματος, η ρίζα
δημιουργεί l splitters. Ο κάθε splitter παίρνει σαν είσοδο το 1/l των γραμμών του αρχείου κειμένου. Η
δουλειά της splitter είναι η παραγωγή λέξεων που υπάρχουν στο κομμάτι του κειμένου της, πλην εκείνων
των λέξεων που δίνονται στο exclusion list. Οι παραγόμενες λέξεις δεν θα πρέπει να έχουν σημεία στίξης,
σύμβολα, ή ψηφία (νούμερα).

4. Κάθε παραγόμενη λέξη αφού περάσει από μια συνάρτηση κατακερματισμού f() οδεύει σε ένα από του n
builder κόμβους. Ο ρόλος της συνάρτησης f() είναι να ‘κατευθύνει’ την ίδια λέξη ανεξάρτητα από το
που παράγεται (splitter) σε ένα και μόνο συγκεκριμένο builder (από τους n που είναι διαθέσιμοι). Για
αυτό το σκοπό ο κάθε splitter θα πρέπει να ανοίξει διόδους επικοινωνίας (pipes ή named pipes) με όλους
τους builders. Οι λέξεις που δεν προωθούνται από splitters σε builders είναι εκείνες που βρίσκονται στο
exclusion list. Η εν λόγω λίστα ορίζεται στην γραμμή κλήσης του προγράμματος.

5. ΄Οταν ένας splitter ολοκληρώσει την εργασία του στέλνει ένα USR1 σήμα ειδοποιώντας έτσι την ρίζα ότι
έχει ολοκληρωθεί η εργασία της και μπορεί να τερματίσει.

6. Ο κόμβος ρίζας επίσης δημιουργεί n κόμβους τύπου builder. Το n είναι παράμετρος που παρέχεται από την
γραμμή εντολής του βασικού προγράμματος. ΄Ολες οι λέξεις που έρχονται σε ένα builder αποθηκεύονται
σε μια δυναμική δομή (λίστα, πίνακας–κατακερματισμού, δένδρο, κλπ) μαζί με ένα μετρητή που δείχνει
πόσες φορές έχει εμφανιστεί μέχρι στιγμής η εν λόγω λέξη στο κείμενο.

7. Ο κάθε builder ολοκληρώνει την εργασία του αφού στείλει όλα τα αποτελέσματά του στην ρίζα (με την
βοήθεια μιας pipe ή named-pipe). Επιπλέον ο κάθε builder πρέπει να αναφέρει στον root το χρόνο που
χρειάστηκε για να ολοκληρώσει την εκτέλεσή του.

8. Η κόμβος ρίζας αναλαμβάνει να ‘συνθέσει’ τα αποτελέσματά από όλους τους builders.

9. Κάθε builder που ολοκληρώνει την εργασία του στέλνει ένα σήμα USR2 στην ρίζα και μπορεί να τερματίσει.

10. Η ρίζα δημιουργεί μια λίστα από τις top-k λέξεις που έχουν παραχθεί με σειρά φθίνουσας συχνότητας. Η
εν λόγω λίστα μπορεί να αποθηκευτεί και σε ένα αρχείο επιλογής σας (μπορεί να ορίζεται στην γραμμή
κλήσης). Η ρίζα τέλος τυπώνει τον αριθμό των USR1 και USR2 σημάτων που έχει λάβει όπως επίσης και
τους χρόνους εκτέλεσης της root καθώς και των builder διεργασιών της ιεραρχίας και τερματίζει.

Το
lexan ολοκληρώνει την εκτέλεση του τυπώνοντας στο tty τα εξής:
1. τις ταξινομημένες top-k λέξεις μαζί με την συχνότητά τους,
2. το χρόνο που χρειάστηκε για να ολοκληρώσει ο κάθε κόμβος–φύλλο την εργασία του,
3. τον αριθμό των σημάτων USR1 και USR2 που έχουν παραληφθεί από την ρίζα.

Η εφαρμογή μπορεί να κληθεί με τον παρακάτω τρόπο:
./lexan -i TextFile -l numOfSplitter -m numOfBuilders -t TopPopular -e ExclusionList -o OutputFile
όπου:
• lexan είναι το εκτελέσιμο (lex-ical an-alysis),
• TextFile είναι το ASCII αρχείο εισόδου,
• numOfSplitter ο αριθμός των κόμβων splitter που θα πρέπει να δημιουργηθούν,
3
• numOfBuilders ο αριθμός των κόμβων builder που θα πρέπει να δημιουργηθούν (καλή ιδέα είναι να πρώτος
αριθμός),
• TopPopular είναι ένα νούμερο που εκφράζει πόσες από τις πιο δημοφιλείς λέξεις θα πρέπει να εμφανιστούν,
• ExclusionList το αρχείο με τις λέξεις που ΔΕΝ θα πρέπει να περάσουν για επεξεργασία στους builders,
• OutputFile το αρχείο που ο root θα τυπώσει όλες τις λέξεις που βρέθηκαν στην διάρκεια της ανάλυσης
μαζί με τους σχετικούς counters.
Οι σημαίες -i/-l/-m/-t/-e/-o μπορούν να χρησιμοποιηθούν με οποιαδήποτε σειρά στην γραμμή εκτέλεσης του
προγράμματος. Τα δεδομένα δίνονται σε ASCII μορφή και δεν υπάρχει καμία πληροφόρια όσον αφορά στο
μέγεθος του αρχείου κειμένου υπό ανάλυση.
